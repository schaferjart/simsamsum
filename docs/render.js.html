<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="utf-8">
    <title>render.js - Documentation</title>


    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >


    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="WorkflowVisualizer.html">WorkflowVisualizer</a><ul class='methods'><li data-type='method'><a href="WorkflowVisualizer.html#applyFilters">applyFilters</a></li><li data-type='method'><a href="WorkflowVisualizer.html#centerGraph">centerGraph</a></li><li data-type='method'><a href="WorkflowVisualizer.html#fitToScreen">fitToScreen</a></li><li data-type='method'><a href="WorkflowVisualizer.html#flipGraph">flipGraph</a></li><li data-type='method'><a href="WorkflowVisualizer.html#handleFileUpload">handleFileUpload</a></li><li data-type='method'><a href="WorkflowVisualizer.html#handleLayoutChange">handleLayoutChange</a></li><li data-type='method'><a href="WorkflowVisualizer.html#handleSizeToggle">handleSizeToggle</a></li><li data-type='method'><a href="WorkflowVisualizer.html#loadSampleData">loadSampleData</a></li><li data-type='method'><a href="WorkflowVisualizer.html#loadSavedLayout">loadSavedLayout</a></li><li data-type='method'><a href="WorkflowVisualizer.html#resetView">resetView</a></li><li data-type='method'><a href="WorkflowVisualizer.html#rotateGraph">rotateGraph</a></li><li data-type='method'><a href="WorkflowVisualizer.html#saveCurrentLayout">saveCurrentLayout</a></li><li data-type='method'><a href="WorkflowVisualizer.html#showConnectionReport">showConnectionReport</a></li><li data-type='method'><a href="WorkflowVisualizer.html#snapAllToGrid">snapAllToGrid</a></li><li data-type='method'><a href="WorkflowVisualizer.html#toggleGrid">toggleGrid</a></li><li data-type='method'><a href="WorkflowVisualizer.html#updateGridSize">updateGridSize</a></li><li data-type='method'><a href="WorkflowVisualizer.html#updateVisualization">updateVisualization</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#applyFilters">applyFilters</a></li><li><a href="global.html#applyLayout">applyLayout</a></li><li><a href="global.html#bindEventListeners">bindEventListeners</a></li><li><a href="global.html#calculateNodeSize">calculateNodeSize</a></li><li><a href="global.html#clearHighlight">clearHighlight</a></li><li><a href="global.html#downloadJsonFile">downloadJsonFile</a></li><li><a href="global.html#dragEnded">dragEnded</a></li><li><a href="global.html#dragStarted">dragStarted</a></li><li><a href="global.html#dragged">dragged</a></li><li><a href="global.html#exportToPDF">exportToPDF</a></li><li><a href="global.html#getBorderStyle">getBorderStyle</a></li><li><a href="global.html#handleResize">handleResize</a></li><li><a href="global.html#handleZoom">handleZoom</a></li><li><a href="global.html#hideDetailsPanel">hideDetailsPanel</a></li><li><a href="global.html#highlightNode">highlightNode</a></li><li><a href="global.html#initVisualization">initVisualization</a></li><li><a href="global.html#initializeApp">initializeApp</a></li><li><a href="global.html#parseCSV">parseCSV</a></li><li><a href="global.html#processData">processData</a></li><li><a href="global.html#renderVisualizationElements">renderVisualizationElements</a></li><li><a href="global.html#resetUI">resetUI</a></li><li><a href="global.html#showNodeDetails">showNodeDetails</a></li><li><a href="global.html#showStatus">showStatus</a></li><li><a href="global.html#snapToGrid">snapToGrid</a></li><li><a href="global.html#toggleGridControls">toggleGridControls</a></li><li><a href="global.html#updateGridDisplay">updateGridDisplay</a></li><li><a href="global.html#updateGridSizeLabel">updateGridSizeLabel</a></li><li><a href="global.html#updateGridUI">updateGridUI</a></li><li><a href="global.html#updatePositions">updatePositions</a></li><li><a href="global.html#updateTextRotation">updateTextRotation</a></li><li><a href="global.html#verifyConnections">verifyConnections</a></li></ul>

</nav>

<div id="main">

    <h1 class="page-title">render.js</h1>







    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as d3 from 'd3';

let svg, zoomGroup, g, zoom;

/**
 * Initializes the main SVG container and zoom capabilities.
 * @param {HTMLElement} container - The container element for the graph.
 * @param {function} onZoom - Callback function for zoom events.
 * @param {function} onBackgroundClick - Callback for clicks on the SVG background.
 * @returns {object} { svg, zoomGroup, g, zoom }
 */
export function initVisualization(container, onZoom, onBackgroundClick) {
    const width = container.clientWidth;
    const height = container.clientHeight;

    d3.select(container).select('svg').remove();

    svg = d3.select(container)
        .append('svg')
        .attr('width', width)
        .attr('height', height);

    svg.append('defs').selectAll('marker')
        .data(['arrowhead'])
        .enter().append('marker')
        .attr('id', d => d)
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 20)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#626c7c');

    zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on('zoom', onZoom);

    svg.call(zoom);

    svg.on('click', (event) => {
        if (event.target === event.currentTarget) {
            onBackgroundClick();
        }
    });

    zoomGroup = svg.append('g');
    g = zoomGroup.append('g');

    addZoomControls(svg, zoom);

    return { svg, zoomGroup, g, zoom, width, height };
}

/**
 * Adds zoom controls to the visualization.
 * @param {d3.Selection} svg - The main SVG selection.
 * @param {d3.ZoomBehavior} zoom - The D3 zoom behavior.
 */
/**
 * Adds zoom controls to the visualization.
 * @param {d3.Selection} svg - The main SVG selection.
 * @param {d3.ZoomBehavior} zoom - The D3 zoom behavior.
 * @private
 */
function addZoomControls(svg, zoom) {
    const container = svg.node().parentNode;
    d3.select(container).select('.zoom-controls').remove();

    const controls = d3.select(container)
        .append('div')
        .attr('class', 'zoom-controls');

    controls.append('button')
        .attr('class', 'zoom-btn')
        .text('+')
        .on('click', () => {
            svg.transition().duration(300).call(zoom.scaleBy, 1.5);
        });

    controls.append('button')
        .attr('class', 'zoom-btn')
        .text('−')
        .on('click', () => {
            svg.transition().duration(300).call(zoom.scaleBy, 1 / 1.5);
        });

    controls.append('button')
        .attr('class', 'zoom-btn')
        .text('⌂')
        .on('click', () => {
            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
        });
}


/**
 * Renders the visual elements of the graph (nodes and links).
 * @param {d3.Selection} g - The main D3 group element for rendering.
 * @param {Array&lt;Object>} nodes - The array of node data.
 * @param {Array&lt;Object>} links - The array of link data.
 * @param {string} currentLayout - The current layout type.
 * @param {object} eventHandlers - Object containing event handlers (drag, click, hover).
 */
export function renderVisualizationElements(g, nodes, links, currentLayout, eventHandlers) {
    g.selectAll('*').remove();

    // Links
    const linkGroup = g.append('g').attr('class', 'links');
    if (currentLayout === 'hierarchical-orthogonal') {
        linkGroup.selectAll('path')
            .data(links)
            .enter().append('path')
            .attr('class', 'link orthogonal-link')
            .attr('fill', 'none')
            .attr('stroke', '#999')
            .attr('stroke-width', 2)
            .attr('marker-end', 'url(#arrowhead)');
    } else {
        linkGroup.selectAll('line')
            .data(links)
            .enter().append('line')
            .attr('class', 'link')
            .attr('stroke', '#999')
            .attr('stroke-width', 2)
            .attr('marker-end', 'url(#arrowhead)');
    }

    // Nodes
    const node = g.append('g')
        .attr('class', 'nodes')
        .selectAll('g')
        .data(nodes)
        .enter().append('g')
        .attr('class', 'node')
        .call(d3.drag()
            .on('start', eventHandlers.dragStarted)
            .on('drag', eventHandlers.dragged)
            .on('end', eventHandlers.dragEnded));

    node.on('click', eventHandlers.nodeClicked);
    node.on('mouseover', eventHandlers.nodeMouseOver)
        .on('mouseout', eventHandlers.nodeMouseOut);

    // Node shapes
    node.each(function (d) {
        const nodeGroup = d3.select(this);
        const size = Math.max(10, d.size || 30);
        const borderStyle = d.borderStyle;

        let shape;
        switch (d.Type) {
            case 'Resource':
                shape = nodeGroup.append('rect')
                    .attr('width', size * 1.2)
                    .attr('height', size * 0.8)
                    .attr('x', -size * 0.6)
                    .attr('y', -size * 0.4);
                break;
            case 'Action':
                const triangleSize = size * 0.8;
                shape = nodeGroup.append('path')
                    .attr('d', `M0,${-triangleSize} L${triangleSize * 0.866},${triangleSize * 0.5} L${-triangleSize * 0.866},${triangleSize * 0.5} Z`);
                break;
            case 'State':
                shape = nodeGroup.append('circle')
                    .attr('r', Math.max(5, size * 0.6));
                break;
            case 'Decision':
                const diamondSize = size * 0.7;
                shape = nodeGroup.append('path')
                    .attr('d', `M0,${-diamondSize} L${diamondSize},0 L0,${diamondSize} L${-diamondSize},0 Z`);
                break;
            default:
                shape = nodeGroup.append('circle')
                    .attr('r', Math.max(5, size * 0.6));
        }

        shape.attr('fill', 'rgba(255, 255, 255, 0.8)')
            .attr('stroke', '#000000')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', borderStyle);
    });

    // Node labels
    node.append('text')
        .attr('class', 'node-label')
        .attr('dy', d => d.size + 20)
        .attr('text-anchor', 'middle')
        .text(d => d.Name.length > 15 ? d.Name.substring(0, 15) + '...' : d.Name);

    node.append('text')
        .attr('class', 'supplementary-info')
        .attr('dy', d => d.size + 35)
        .attr('text-anchor', 'middle')
        .text(d => {
            const cost = d["Effective Cost"] || d["Ø Cost"];
            return cost ? `€${cost}` : '';
        });
}

/**
 * Updates the positions of nodes and links.
 * @param {d3.Selection} g - The main D3 group element.
 */
export function updatePositions(g) {
    if (!g) return;
    g.selectAll('.node').attr('transform', d => `translate(${d.x},${d.y})`);

    g.selectAll('line.link')
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y);

    g.selectAll('path.link').attr('d', createOrthogonalPath);
}

/**
 * Creates an orthogonal path for a link.
 * @param {object} d - The link data.
 * @returns {string} The SVG path string.
 */
/**
 * Creates an SVG path string for an orthogonal link between two nodes.
 * This function is used specifically for the 'hierarchical-orthogonal' layout to draw
 * links with 90-degree bends, creating a cleaner, more structured look.
 * @param {object} d - The link data object, which must contain `source` and `target` node objects.
 * @returns {string} The SVG path data string (e.g., "M x1,y1 L x2,y2 ...").
 * @private
 */
function createOrthogonalPath(d) {
    const { source, target } = d;
    const sourceSize = source.size || 30;
    const targetSize = target.size || 30;

    const sourceY = source.y + sourceSize / 2 + 5;
    const targetY = target.y - targetSize / 2 - 5;
    const sourceX = source.x;
    const targetX = target.x;

    const horizontalDistance = Math.abs(targetX - sourceX);
    const verticalDistance = Math.abs(targetY - sourceY);

    if (horizontalDistance &lt; 20) {
        return `M${sourceX},${sourceY} L${targetX},${targetY}`;
    }

    if (verticalDistance > 100) {
        const bendY = sourceY + (targetY - sourceY) * 0.55;
        return `M${sourceX},${sourceY} L${sourceX},${bendY} L${targetX},${bendY} L${targetX},${targetY}`;
    } else {
        const routingOffset = Math.max(40, verticalDistance * 0.7);
        const bendY = sourceY + routingOffset;
        return `M${sourceX},${sourceY} L${sourceX},${bendY} L${targetX},${bendY} L${targetX},${targetY}`;
    }
}

/**
 * Highlights a node and its connections.
 * @param {d3.Selection} g - The main D3 group element.
 * @param {object} selectedNode - The node to highlight.
 * @param {Array&lt;Object>} links - All links in the graph.
 */
export function highlightNode(g, selectedNode, links) {
    if (!g) return;
    const connectedNodes = new Set([selectedNode.id]);
    links.forEach(link => {
        if (link.source.id === selectedNode.id || link.source === selectedNode.id) {
            connectedNodes.add(link.target.id || link.target);
        }
        if (link.target.id === selectedNode.id || link.target === selectedNode.id) {
            connectedNodes.add(link.source.id || link.source);
        }
    });

    g.selectAll('.node')
        .classed('highlighted', d => d.id === selectedNode.id)
        .classed('dimmed', d => !connectedNodes.has(d.id));

    g.selectAll('.link')
        .classed('highlighted', d => (d.source.id || d.source) === selectedNode.id || (d.target.id || d.target) === selectedNode.id)
        .classed('dimmed', d => !((d.source.id || d.source) === selectedNode.id || (d.target.id || d.target) === selectedNode.id));

    g.selectAll('.node-label, .supplementary-info')
        .classed('dimmed', d => !connectedNodes.has(d.id));
}

/**
 * Clears all highlighting from the graph.
 * @param {d3.Selection} g - The main D3 group element.
 */
export function clearHighlight(g) {
    if (!g) return;
    g.selectAll('.node, .link, .node-label, .supplementary-info')
        .classed('highlighted', false)
        .classed('dimmed', false);
}

/**
 * Updates the rotation of text elements to keep them readable.
 * @param {d3.Selection} g - The main D3 group element.
 * @param {number} graphRotation - The current rotation of the graph.
 * @param {object} graphTransform - The current transform of the graph.
 */
export function updateTextRotation(g, graphRotation, graphTransform) {
    if (!g) return;
    const counterRotation = -graphRotation;
    const textScaleX = graphTransform.scaleX &lt; 0 ? -1 : 1;
    const textScaleY = graphTransform.scaleY &lt; 0 ? -1 : 1;

    g.selectAll('.node-label, .supplementary-info')
        .transition()
        .duration(300)
        .attr('transform', `rotate(${counterRotation}) scale(${textScaleX}, ${textScaleY})`);
}

/**
 * Updates the display of the grid overlay.
 * @param {d3.Selection} svg - The main SVG selection.
 * @param {boolean} showGrid - Whether to show the grid.
 * @param {number} width - The width of the SVG.
 * @param {number} height - The height of the SVG.
 * @param {number} gridSize - The size of the grid cells.
 */
export function updateGridDisplay(svg, showGrid, width, height, gridSize) {
    if (!svg) return;
    svg.selectAll('.grid-line').remove();
    if (!showGrid) return;

    const gridGroup = svg.insert('g', ':first-child').attr('class', 'grid-overlay');

    for (let x = 0; x &lt;= width; x += gridSize) {
        gridGroup.append('line')
            .attr('class', 'grid-line')
            .attr('x1', x).attr('y1', 0)
            .attr('x2', x).attr('y2', height)
            .attr('stroke', '#e0e0e0')
            .attr('stroke-width', x % (gridSize * 4) === 0 ? 1 : 0.5)
            .attr('opacity', 0.5);
    }

    for (let y = 0; y &lt;= height; y += gridSize) {
        gridGroup.append('line')
            .attr('class', 'grid-line')
            .attr('x1', 0).attr('y1', y)
            .attr('x2', width).attr('y2', y)
            .attr('stroke', '#e0e0e0')
            .attr('stroke-width', y % (gridSize * 4) === 0 ? 1 : 0.5)
            .attr('opacity', 0.5);
    }
}</code></pre>
        </article>
    </section>






</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a> on Fri Sep 26 2025 13:40:40 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
